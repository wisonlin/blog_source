<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 苹果君的博客]]></title>
  <link href="http://wison.me/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wison.me/"/>
  <updated>2014-08-10T14:34:20+08:00</updated>
  <id>http://wison.me/</id>
  <author>
    <name><![CDATA[苹果君]]></name>
    <email><![CDATA[460760604@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSHashTable 引起的性能问题]]></title>
    <link href="http://wison.me/blog/2014/08/10/nshashtable-yin-qi-de-xing-neng-wen-ti/"/>
    <updated>2014-08-10T01:46:40+08:00</updated>
    <id>http://wison.me/blog/2014/08/10/nshashtable-yin-qi-de-xing-neng-wen-ti</id>
    <content type="html"><![CDATA[<p>  本文介绍了在 Core Text 排版中，往 NSAttributeString 增加一个属性时引起的性能问题。</p>

<!-- more -->


<p>  在 Feeds 的 Core Text 排版中，NSAttributeString 中的某一小段的点击跳转行为是存储在 NSAttributeString 的属性中的。</p>

<p>代码如下：</p>

<p>  <img src="/images/2014-08-10-1-1.png" alt="image" /></p>

<p>  QZTextLinkHelper 存储了点击跳转的相关信息，比如 url 跳转，昵称跳转等。</p>

<p>  setLinkHelper 做为 NSAttributeString 的扩展方法，通过 [NSAttributeString addAttribute:value:range] 方法存储 linkHelper 的属性。</p>

<p>  这里，linkHelper 的 linkAttributes 是一个 NSDictionary 对象。</p>

<p>  好，问题出来了。我们发现，Feeds 排版变得异常耗时，滑动卡顿，profile 一下之后发现一个奇怪的热点：</p>

<p>  <img src="/images/2014-08-10-1-2.jpeg" alt="image" /></p>

<p>  [NSAttributeString addAttribute:value:range] 里面耗时很多，仔细看调用栈发现，内部的 attribute 都是通过 NSHashTable 存储的。</p>

<p>  堆栈中出现的 [NSHashTable member:] 是取值操作，耗时主要在最后的比较两个 Dictionary 是否相等上面。</p>

<p>  我们先重温一下哈希表取值的原理，见下图，红色部分代表耗时很长的步骤。</p>

<p>  <img src="/images/2014-08-10-1-3.png" alt="image" /></p>

<p>  根据上图，我们可以看出，当哈希表频繁对比两个对象是否相等的时候，说明哈希表的键冲突已经非常严重了。</p>

<p>  于是转而把目光转向 NSDictionary 是怎么计算自己的哈希值的。</p>

<p>  写了一个 demo 试了一下，发现 NSDictionary 的哈希值等于其 key 的个数，非常简单的一个计算，也非常容易冲突。</p>

<p>  于是，解决方法就是在 addAttribute 的时候直接塞入 linkHelper 就可以了。
  因为NSObject的哈希值默认是指针地址。</p>

<p>总结：</p>

<p>  [NSAttributeString addAttribute:value:range] 这个方法如果传入一个 NSDictionary 会非常耗时，原因有两个：</p>

<ol>
<li><p> NSAttributeString 以 HashTable 的方式存储 attribute，这使 attribute 的存取变得很复杂，我们必须确保传入的自定义 attribute 的哈希值不易冲突，或者保证其 isEqual 方法的效率。</p></li>
<li><p> NSDictionary 的哈希值计算太过于简单了，基本不能跟 NSHashTable 这种容器共存。</p></li>
</ol>


<p>附：调用 [NSHashTable addObject:] 传入不同对象时的性能对比。</p>

<p>10000个NSNumber：2ms</p>

<p>10000个相同的NSDictionary：33000ms</p>

<p>10000个key数量各不相同的NSDictionary：400ms</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS 增量更新机制介绍]]></title>
    <link href="http://wison.me/blog/2014/08/09/ios-zeng-liang-geng-xin-ji-zhi-jie-shao/"/>
    <updated>2014-08-09T19:41:08+08:00</updated>
    <id>http://wison.me/blog/2014/08/09/ios-zeng-liang-geng-xin-ji-zhi-jie-shao</id>
    <content type="html"><![CDATA[<p>  从 iOS6 开始，iOS 引入了增量更新(delta update)，App Store 对应用的新版本更新的提交，会自动生成增量更新包。
  用户在更新应用的新版本的时候，只会下载差异部分，这样就加快了下载速度，也同时提升了安装速度。
  本文介绍了 iOS 的增量更新机制，以及优化应用安装包大小时应注意的问题。</p>

<!-- more -->


<h3>差异化更新的机制：</h3>

<p>  自动生成更新包的时候，App Store 将会比较应用的每一个老版本和新版本的差异，针对每一个旧版本，生成一个更新包，每一个更新包里面，只包含了两个版本之间有变化的文件，而没有变化的文件则不包含。应用更新包中除了有差异的内容之外，还包括了一个简单的命令脚本，存储增加，更新，删除某个文件的命令，安装的时候将被执行。
  差异化更新的这个过程，对于开发者和用户都是透明的，并且，用更新包更新应用和直接下载完整包安装没有任何区别。</p>

<h3>差异化更新的好处：</h3>

<p>  有了差异化更新之后，更新包将会比应用的完整安装包小很多，并且安装也将更快。
  我们都知道，蜂窝网络下，应用的安装包超过某一个大小的时候，将不支持下载。但是，如果更新包小于这个限制大小的话，大型应用也可以在蜂窝网络下更新。</p>

<h3>针对这样的机制，有两个建议，可以优化用户更新应用的速度：</h3>

<ol>
<li> 不要对文件进行不必要的更改，可以在发布之前用文件比较工具比较一下。</li>
<li> 如果可能，将频繁变化的文件和其他文件分开，减少差异更新包的大小，以及加快安装速度。</li>
</ol>


<p>  在 iOS 6 上，差异更新的粒度是文件级，就是说文件一旦有变化，将会被完全放入更新包中，比如有个10MB的文件，只改动了里面的一点点内容，那么整个10MB的文件都会被塞进更新包中下发给用户。</p>

<p>  但是，在 iOS 7 以后，差异更新的粒度优化成了字节级的比较，更新包中只会包含文件之间的差异部分，而不是整个文件。这样的话，如果文件之间只有小小的差异的时候，更新包将会比之前小很多，但是同时也降低了安装的速度。
  所以，即使是在iOS 7之后，以上的两条建议依然很重要。在 iOS 7 以上的系统，减少文件改动，和隔离频繁更改的文件，不仅会减小更新包大小，也会提高安装速度。</p>

<h3>注意：</h3>

<ol>
<li> 这个功能只有在开发者提交新版本应用到 App Store 的时候才有用，比如通过企业证书直接分发应用的时候是没有这个功能的。</li>
<li> 本文描述的文件差异比较，不包括文件的创建时间，修改时间。也就是说，当我们的文件只有创建时间和修改时间被更改的时候，文件是不会被更新的。所以我们的应用，不要依赖安装包里面文件的创建时间和修改时间。</li>
</ol>


<h3>我们的工作：</h3>

<p>  iOS 的这套方案非常优雅，不需要开发者做额外的工作，并且更新中没有不必要的开销，这得益于渠道的统一。我们优化安装包大小的时候，应该包含两个目标：</p>

<ol>
<li> 通过减少安装包文件，压缩安装包文件，来提升用户的第一次安装应用的体验。</li>
<li> 同时，减少文件更改，隔离文件频繁变动的部分，来提升用户的升级应用的体验。</li>
</ol>


<p>  同时，在过去我们优化安装包大小的时候，其实踩到了两个陷阱：</p>

<ol>
<li> 我们会通过压缩安装包的所有图片，来减小安装包的大小，其实这样会更改大量的文件，导致更新包变大，需要权衡压缩效果和对更新包大小的影响。</li>
<li> 我们会通过合并图片资源文件，来减小文件大小，以及提升读取文件速度。这样合并后的大文件的更新频率会提高，增大了更新包大小，以及降低了安装速度(iOS7以上会增加合并文件的操作)。所以这种方案也是需要权衡的。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[判断自己的应用是否被调试启动]]></title>
    <link href="http://wison.me/blog/2014/08/09/pan-duan-zi-ji-de-ying-yong-shi-fou-bei-diao-shi-qi-dong/"/>
    <updated>2014-08-09T14:41:33+08:00</updated>
    <id>http://wison.me/blog/2014/08/09/pan-duan-zi-ji-de-ying-yong-shi-fou-bei-diao-shi-qi-dong</id>
    <content type="html"><![CDATA[<p>转自：<a href="https://developer.apple.com/library/ios/qa/qa1361/_index.html#//apple_ref/doc/uid/DTS10003368">https://developer.apple.com/library/ios/qa/qa1361/_index.html#//apple_ref/doc/uid/DTS10003368</a></p>

<p>目前能够想到的两个用处：</p>

<ol>
<li>加入一些开发调试过程中才运行的代码，方便开发。</li>
<li>可以检测到被恶意调起，终止敏感操作。</li>
</ol>


<!-- more -->


<p>```</p>

<h1>include &lt;assert.h></h1>

<h1>include &lt;stdbool.h></h1>

<h1>include &lt;sys/types.h></h1>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;sys/sysctl.h></h1>

<p>static bool AmIBeingDebugged(void)</p>

<pre><code>// Returns true if the current process is being debugged (either 
// running under the debugger or has a debugger attached post facto).
</code></pre>

<p>{</p>

<pre><code>int                 junk;
int                 mib[4];
struct kinfo_proc   info;
size_t              size;

// Initialize the flags so that, if sysctl fails for some bizarre 
// reason, we get a predictable result.

info.kp_proc.p_flag = 0;

// Initialize mib, which tells sysctl the info we want, in this case
// we're looking for information about a specific process ID.

mib[0] = CTL_KERN;
mib[1] = KERN_PROC;
mib[2] = KERN_PROC_PID;
mib[3] = getpid();

// Call sysctl.

size = sizeof(info);
junk = sysctl(mib, sizeof(mib) / sizeof(*mib), &amp;info, &amp;size, NULL, 0);
assert(junk == 0);

// We're being debugged if the P_TRACED flag is set.

return ( (info.kp_proc.p_flag &amp; P_TRACED) != 0 );
</code></pre>

<p>}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can't Add Self as Subview]]></title>
    <link href="http://wison.me/blog/2014/06/01/cant-add-self-as-subview/"/>
    <updated>2014-06-01T11:37:34+08:00</updated>
    <id>http://wison.me/blog/2014/06/01/cant-add-self-as-subview</id>
    <content type="html"><![CDATA[<p>iOS7刚发布的时候，总是出现这个 Can&rsquo;t add self as subview  的崩溃，团队内部没出现过，但是外部用户的crash频频上报这个崩溃。本文讲述发现这个bug，分析定位，到解决的过程。</p>

<!-- more -->


<p>异常描述和崩溃堆栈是这样的：</p>

<p>*** Terminating app due to uncaught exception &lsquo;NSInvalidArgumentException&rsquo;, reason: &lsquo;Can&rsquo;t add self as subview&rsquo;</p>

<p><img src="/images/2014-06-01-1.jpg" alt="image" /></p>

<p>这里有两个线索，一个是从崩溃堆栈中看到了崩溃的时间点：导航栏对内部的控制器做切换动画的时候崩溃。</p>

<p>另一个线索则是addSubView的参数不能是对象本身。一开始怀疑是addSubView传入self引起，于是用类似 [self addSubView:self] 的代码试了一下，的确是会崩溃的。</p>

<p><img src="/images/2014-06-01-1.jpg" alt="image" /></p>

<p>但是堆栈跟外部用户上报的不一样，排除 [self addSubView:self] 直接导致崩溃的可能性。</p>

<p>也就是说，不是我们工程调用了[self addSubView:self] 引起崩溃，
而是我们工程里面的某一些代码会导致UIKit内部执行 addSubView 的时候，传入了 self。
为什么说是我们的代码引起呢？因为崩溃的时候，页面总是停留在某几个特定的页面，这个后面会分析。</p>

<p>再看看第二个线索，即导航栏在做动画的时候出了问题。</p>

<p>以上，我们可以得出一个中间结论，即我们的代码，让导航栏在做动画的时候，执行了一次 [self addSubView:self]。
再说说崩溃集中的几个页面，用户上报的崩溃中，并不是总在一个页面崩溃，但是固定出现在特定的某几个页面。</p>

<p>着重看了log里面崩溃前每一个页面切换的时间，果然比较短，有些甚至少于0.5秒，少于导航栏push和pop动画的时间。
接着，用代码模拟一下快速切换的场景，比如0.3秒只能做两次push操作：</p>

<p>```objc
[navigationController pushViewController:[[TMViewController alloc] init] animated:YES];</p>

<pre><code>dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.3 * NSEC_PER_SEC)), 
dispatch_get_main_queue(), ^{
[navigationController pushViewController:[[TMViewController alloc] init] animated:YES];
</code></pre>

<p>}
```</p>

<p>果然崩溃了，得到的堆栈跟文章开头的一模一样。</p>

<p>接着，检查崩溃上报的其他页面，发现这些页面都在特定的场景下会出现同时做push或者pop操作的情况。
于是，模拟各种短时间push和pop页面的场景，都会出现这样的崩溃。
这时候几乎已经明确了就是动画被打断引起的。</p>

<p>原来，其实就是iOS5，6下的nested push 问题，只不过到iOS7上，这个问题的提前在做动画的时候崩溃了。</p>

<p>为了防止这种情况，我们在UINavigationController基类中加入防御，具体做法是在push，pop方法中设置一个标志位(animating=YES)，在动画结束之后，再重置这个标志位，然后，用这个标志位判断push和pop操作是否能够执行。</p>

<p>比如，push这样实现：</p>

<p>```objc
&ndash; (void)pushViewController:(UIViewController *)viewController animated:(BOOL)animated
{</p>

<pre><code>if (self.topViewController.animating) {
    NSLog(@"error push when animating.");
    return;
}
self.topViewController.animating = animated;
viewController.animating = animated;
[super pushViewController:viewController aniamted:animated];
</code></pre>

<p>}
```</p>

<p>其中有一个细节是，参与动画的两个控制器都需要设标志位。
结束动画的时候重置标志位，时机是在控制器的viewDidAppear和viewDidDisappear里面。</p>

<p>```objc
&ndash; (void)viewDidAppear:(BOOL)animated
{</p>

<pre><code>[super viewDidAppear:animated];
self.animating = NO;
</code></pre>

<p>}</p>

<ul>
<li>(void)viewDidDisappear:(BOOL)animated
{
  [super viewDidDisappear:animated];
  self.animating = NO;
}</li>
</ul>


<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[viewDidUnload 和 viewWillUnload 被废弃之后的内存警告处理]]></title>
    <link href="http://wison.me/blog/2013/04/07/viewdidunload-he-viewwillunload-bei-fei-qi-zhi-hou-de-nei-cun-jing-gao-chu-li/"/>
    <updated>2013-04-07T21:31:24+08:00</updated>
    <id>http://wison.me/blog/2013/04/07/viewdidunload-he-viewwillunload-bei-fei-qi-zhi-hou-de-nei-cun-jing-gao-chu-li</id>
    <content type="html"><![CDATA[<p>由于iOS6以上的UIKit不会在内存警告时自动释放视图，所以viewWillUnload和viewDidUnload将不再触发，因此，在iOS6上，开发者需要负责内存警告时将不用到的视图释放。</p>

<!-- more -->


<p>WWDC2012的视频有提到，具体代码如下：</p>

<p>```objc
&ndash; (void)didReceiveMemoryWarning {</p>

<pre><code> if ([self.view window] == nil) {
      self.view = nil;
      self.otherSubView = nil;
 }
</code></pre>

<p>}
```</p>

<p>由于[self view]会引发视图的加载所以上述代码还是有潜在风险的，假如视图控制器在创建之后，在还没有加载视图时收到内存警告，那上面的代码就会触发视图的加载（调用了[self view]引起），反而加大了内存占用。所以应该先判断一下视图是否已被加载。</p>

<p>```objc
&ndash; (void)didReceiveMemoryWarning {</p>

<pre><code> if ([self isViewLoaded] &amp;&amp; [self.view window] == nil) {
      self.view = nil;
      self.otherSubView = nil;
 }
</code></pre>

<p>}
```</p>

<p>Notification 的注册和反注册以及Delegate的设置和置空</p>

<p>如果注册的通知跟界面相关，可以考虑将注册放入viewWillAppear并在viewWillDisappear中反注册。
如果需要在视图加载时就注册，那就在viewDidLoad注册，dealloc和didReceiveMemoryWarning中根据视图是否加载过来进行反注册。
注意viewDidUnload和viewDidLoad不是成对调用的，所以即使是iOS5或者以下的版本也不能在viewDidUnload里面反注册。参见[iOS] ViewController的生命周期及其加载View的步骤。</p>

<p>综上所述，最佳实践的代码如下：</p>

<p>```objc
&ndash; (void)viewDidLoad
{</p>

<pre><code> self.subView.delegate = self;
 [[NSNotificationCenter defaultCenter] addObserver:self];
 self.viewCreatedByCode = [[UIView alloc] init];
</code></pre>

<p>}</p>

<p>// 自定义函数viewUnloaded，其操作与viewDidLoad对称。
&ndash; (void)viewUnloaded
{</p>

<pre><code> self.subView.delegate = nil;
 [[NSNotificationCenter defaultCenter] removeObserver:self];
 self.viewCreatedByCode = nil;
</code></pre>

<p>}</p>

<ul>
<li><p>(void)didReceiveMemoryWarning {
   if ([self isViewLoaded] &amp;&amp; [self.view window] == nil) {
        self.view = nil; // 需要开发者手动释放控制器的视图。
        self.viewCreatedByNib = nil;  // 在xib中创建的视图也要手动清空。
        [self viewUnloaded]; // 视图已被卸载，调用viewDIdLoad的反操作。
   }
}</p></li>
<li><p>(void)dealloc
{
   if ([self isViewLoaded]) {
        [self viewUnloaded]; // 如果视图已被加载，说明viewDidLoad被调用过，所以调用viewDIdLoad的反操作。
   }
}</p></li>
<li><p>(void)viewDidLoad
{
   self.subView.delegate = self;
   [[NSNotificationCenter defaultCenter] addObserver:self];
   self.viewCreatedByCode = [[UIView alloc] init];
}</p></li>
<li><p>(void)viewDidUnload
{
   self.subView.delegate = nil;
   [[NSNotificationCenter defaultCenter] removeObserver:self];
   self.viewCreatedByCode = nil;
}</p></li>
<li><p>(void)didReceiveMemoryWarning {
   if ([self isViewLoaded] &amp;&amp; [self.view window] == nil) {
       [self.photoCache removeAllObjects];
       if (>=iOS6) {
            self.view = nil;
            [self viewDidUnload];
       }
   }
}</p></li>
<li><p>(void)dealloc
{
   if ([self isViewLoaded]) {
       [[NSNotificationCenter defaultCenter] removeObserver:self];
   }
}
```</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
